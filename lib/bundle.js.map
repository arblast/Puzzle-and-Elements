{"version":3,"sources":["webpack:///webpack/bootstrap 13b2ab841134673beb93","webpack:///./lib/puzzles.js","webpack:///./lib/board.js","webpack:///./lib/orb.js","webpack:///./lib/game_view.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAC;;;;;;;ACZD,iBAAgB;AAChB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,kCAAiC,QAAQ;AACzC,oCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAoB,gCAAgC,aAAa,EAAE,EAAE;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;;AAEA;;;;;;;AC3MA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA","file":"./lib/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 13b2ab841134673beb93\n **/","const Board = require('./board.js');\nconst GameView = require('./game_view.js');\n\ndocument.addEventListener(\"DOMContentLoaded\", function(){\n  const canvasEl = document.getElementsByTagName(\"canvas\")[0];\n  canvasEl.width = 400;\n  canvasEl.height = 400;\n\n  const ctx = canvasEl.getContext(\"2d\");\n  const board = new Board(400,400,6,6,35, canvasEl, ctx);\n  new GameView(board, ctx).start();\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/puzzles.js\n ** module id = 0\n ** module chunks = 0\n **/","const COLORS = {water: '#3498DB',wood: '#3AF508', fire: '#F51A08', electric: '#FDFE00', wind: '#ABAB9E'};\nconst Orb = require('./orb.js');\n\nconst CSSOFFSET = 50;\nconst TIMETOMOVE = 6000;\nclass Board {\n\n  constructor(width, height, row, col, offset=0, canvas) {\n    this.offset = offset;\n    this.row = row;\n    this.col = col;\n    this.width = width;\n    this.height = height;\n    this.grid = new Array(row);\n    this.canvas = canvas;\n    this.matchedOrbs = [];\n    this.resolving = false;\n    for (var i = 0; i < row; i++) {\n      this.grid[i] = new Array(col);\n    }\n    canvas.onmousedown = this.checkMouseDown.bind(this);\n\n  }\n\n  checkMouseDown(e) {\n    this.mouseX = e.pageX - this.canvas.offsetLeft -10;\n    this.mouseY = e.pageY - this.canvas.offsetTop - 10;\n    this.eachOrb( (orb) => {\n      if(Math.sqrt((this.mouseX-orb.x)*(this.mouseX-orb.x) + (this.mouseY-orb.y)*(this.mouseY-orb.y)) < orb.radius) {\n        this.selectedOrb = orb;\n        orb.select();\n        this.canvas.onmousemove = this.checkMouseMove.bind(this);\n        this.canvas.onmouseup = this.checkMouseUp.bind(this);\n      }\n    })\n  }\n\n  checkMouseUp() {\n    // this.mouseX = e.clientX - 50;\n    // this.mouseY = e.clientY - 50;\n    this.canvas.onmousemove = null;\n    this.canvas.onmouseup = null;\n    this.selectedOrb.unselect();\n    this.selectedOrb = null;\n    clearTimeout(this.timer);\n    if(this.timer){\n      this.resolveBoard();\n    }\n    this.timer = null;\n  }\n\n  checkMouseMove(e) {\n    this.mouseX = e.pageX - this.canvas.offsetLeft -10;\n    this.mouseY = e.pageY - this.canvas.offsetTop - 10;\n\n    this.eachOrb( (orb) => {\n      if(Math.sqrt((this.mouseX-orb.x)*(this.mouseX-orb.x) + (this.mouseY-orb.y)*(this.mouseY-orb.y)) < orb.radius) {\n        if (this.selectedOrb != orb && !this.timer) {\n          this.timer = setTimeout(this.checkMouseUp.bind(this), TIMETOMOVE);\n        } else if (this.selectedOrb != orb) {\n          this.swapOrbs(orb);\n        }\n      }\n    })\n    if(this.mouseX < 3 || this.mouseY < 3 || this.mouseX > this.width -3 || this.mouseY > this.height -3 ) {\n      this.checkMouseUp();\n    }\n  }\n\n  checkRow(grid) {\n    grid.forEach((row) => {\n      let matches = [];\n      let lastColor = null;\n      row.forEach((orb) => {\n        if(lastColor) {\n          if(lastColor === orb.color) {\n            matches.push(orb);\n          } else if(lastColor != orb.color && matches.length > 2) {\n            this.matchedOrbs = this.matchedOrbs.concat(matches);\n            matches = [];\n            matches.push(orb);\n            lastColor = orb.color;\n          } else {\n            matches = [];\n            matches.push(orb);\n            lastColor = orb.color;\n          }\n        } else {\n          lastColor = orb.color;\n          matches.push(orb);\n        }\n      })\n      if(matches.length > 2) {\n        this.matchedOrbs = this.matchedOrbs.concat(matches);\n      }\n    })\n  }\n\n  checkCol(grid) {\n    let transposedGrid = this.transpose(grid);\n    this.checkRow(transposedGrid);\n  }\n\n  populate(){\n    this.grid.forEach((row, i) => {\n      for ( var j=0; j < row.length; j++) {\n        const x = j*this.width/this.col + this.offset;\n        const y = i*this.height/this.row + this.offset;\n        this.grid[i][j] = new Orb(x,y);\n      }\n    });\n  }\n\n  draw(ctx) {\n    if(this.resolving && !this.falling()) {\n      this.skyfall();\n    }\n    ctx.clearRect(0,0,this.width+this.offset,this.height+this.offset);\n    this.eachOrb((orb) => orb.draw(ctx));\n    if(this.selectedOrb) {\n      let image = document.getElementById(this.selectedOrb.color);\n      ctx.drawImage(image,this.mouseX - 30,this.mouseY - 30,70,70);\n    }\n  }\n\n  falling() {\n    let result = false;\n    this.eachOrb( (orb) => {\n      if (orb.targetY) {\n        result = true;\n      }\n    })\n    return result;\n  }\n\n  skyfall() {\n    this.skyfalling = false;\n    this.grid[0].forEach( orb => {\n      if(orb.disappeared) {\n        orb.generateNewColor();\n        orb.respawn();\n      }\n    })\n    for(let i=this.grid.length-1; i >= 1; i--) {\n      for(let j=this.grid.length-1; j >= 0; j--) {\n        if(this.grid[i][j].disappeared && !this.grid[i-1][j].disappeared) {\n          this.skyfalling = true;\n          let tempOrb = this.grid[i][j];\n          this.dropOrb(this.grid[i-1][j], this.grid[i][j]);\n          this.grid[i][j] = this.grid[i-1][j];\n          this.grid[i-1][j] = tempOrb;\n        }\n      }\n    }\n    if(!this.skyfalling) {\n      this.resolveBoard();\n    }\n  }\n\n  swapOrbs(otherOrb) {\n    let tempColor = this.selectedOrb.color;\n    this.selectedOrb.color = otherOrb.color;\n    this.selectedOrb.unselect();\n    otherOrb.color = tempColor;\n    this.selectedOrb = otherOrb;\n    this.selectedOrb.select();\n  }\n\n  dropOrb(orb, disappearedOrb) {\n    let oldY = orb.y;\n    orb.targetY = disappearedOrb.y;\n    disappearedOrb.y = oldY;\n  }\n\n  resolveBoard() {\n    this.resolving = true;\n    this.canvas.onmousedown = null;\n    this.checkRow(this.grid);\n    this.checkCol(this.grid);\n    if(this.matchedOrbs.length === 0) {\n      this.resolving = false;\n      this.canvas.onmousedown = this.checkMouseDown.bind(this);\n    }\n    this.matchedOrbs.forEach((orb) => orb.disappear())\n    this.matchedOrbs = [];\n  }\n\n  transpose(array) {\n    return Object.keys(array[0]).map(\n      function (c) { return array.map(function (r) { return r[c]; }); }\n      );\n    }\n\n  eachOrb(callback) {\n    this.grid.forEach((row) => {\n      row.forEach((orb) => {\n        callback(orb);\n      });\n    });\n  }\n\n}\n\nmodule.exports = Board;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/board.js\n ** module id = 1\n ** module chunks = 0\n **/","const COLORS = ['water', 'wood', 'fire', 'electric', 'wind'];\n\nclass Orb {\n\n  constructor(x,y) {\n    this.radius = 34;\n    this.x = x;\n    this.y = y;\n    this.opacity = 1;\n    this.targetY = null;\n    this.color = COLORS[Math.floor(Math.random()*COLORS.length)];\n  }\n\n  generateNewColor() {\n    this.color = COLORS[Math.floor(Math.random()*COLORS.length)];\n  }\n\n  draw(ctx) {\n    ctx.save();\n    this.img = COLORS[this.color]\n    if(this.disappearing && this.opacity >= 0.03) {\n      this.opacity = this.opacity - 0.03;\n    } else if (this.opacity < 0.03){\n      this.disappearing = false;\n      this.disappeared = true;\n    } else {\n      this.disappearing = false;\n    }\n    if(this.targetY && this.y <= (this.targetY + 0.1 - 10/3)) {\n      this.y = this.y + 10/3;\n    } else {\n      this.targetY = null;\n    }\n    ctx.globalAlpha = this.opacity;\n    // ctx.beginPath();\n    // ctx.fillStyle = this.img;\n    // ctx.arc(this.x,this.y,this.radius,0,2*Math.PI,false);\n    // ctx.fill();\n    let image = document.getElementById(this.color);\n    ctx.drawImage(image,this.x - 34,this.y - 34,this.radius*2,this.radius*2);\n    ctx.restore();\n  }\n\n  disappear() {\n    this.disappearing = true;\n  }\n\n  respawn() {\n    this.disappeared = false;\n    this.opacity = 1;\n  }\n\n  select() {\n    this.opacity = 0.4;\n  }\n\n  unselect() {\n    this.opacity = 1;\n  }\n\n\n  // move(x,y) {\n  //   this.x = x;\n  //   this.y = y;\n  // }\n\n  // drag(x,y) {\n  //   if(this.selected) {\n  //     this.x = x;\n  //     this.y = y;\n  //   }\n  // }\n\n\n}\n\nmodule.exports = Orb;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/orb.js\n ** module id = 2\n ** module chunks = 0\n **/","\nclass GameView {\n  constructor(board, ctx) {\n    this.ctx = ctx;\n    this.board = board;\n    this.board.populate();\n  }\n\n  start() {\n    this.lastTime = 0;\n    requestAnimationFrame(this.animate.bind(this));\n  }\n\n  animate(time) {\n    this.board.draw(this.ctx);\n    this.lastTime = time;\n    requestAnimationFrame(this.animate.bind(this));\n  }\n\n}\n\nmodule.exports = GameView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/game_view.js\n ** module id = 3\n ** module chunks = 0\n **/"],"sourceRoot":""}