{"version":3,"sources":["webpack:///webpack/bootstrap 821078ae0384bb8a6e7a","webpack:///./lib/puzzles.js","webpack:///./lib/board.js","webpack:///./lib/orb.js","webpack:///./lib/game_view.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;;;;;;AC/BD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;;AAEA;;AAEA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA,mBAAkB;AAClB;AACA;AACA;;AAEA,cAAa;AACb;AACA,qBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,oCAAmC,QAAQ;AAC3C,sCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA,oBAAmB,6BAA6B;AAChD,sBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA,iCAAgC;AAChC;AACA;AACA;AACA;;AAEA,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB;AACA,qBAAoB,gCAAgC,aAAa,EAAE,EAAE;AACrE;AACA;;AAEA,sBAAqB;AACrB;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;;AAEA;;;;;;;AC/TA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAsB;AACtB;AACA;;AAEA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;ACzDA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA","file":"./lib/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 821078ae0384bb8a6e7a\n **/","const Board = require('./board.js');\nconst GameView = require('./game_view.js');\n\nconst modal = document.getElementById('rulesModal');\nconst rulesLink = document.getElementById(\"rules\");\nconst close = document.getElementsByClassName(\"close\")[0];\n\n//modal functions\nrulesLink.onclick = () => {\n    modal.style.display = \"block\";\n}\nclose.onclick = () => {\n    modal.style.display = \"none\";\n}\nwindow.onclick = (e) => {\n    if (e.target == modal) {\n        modal.style.display = \"none\";\n    }\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", function(){\n  const canvasEl = document.getElementsByTagName(\"canvas\")[0];\n  canvasEl.width = 400;\n  canvasEl.height = 400;\n\n  const difficulty = document.getElementById(\"difficulty\");\n  const ctx = canvasEl.getContext(\"2d\");\n  const board = new Board(400,400,6,6,34,33, canvasEl, ctx);\n  difficulty.onchange = (e) => board.timeToMove = e.target.value;\n  new GameView(board, ctx).start();\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/puzzles.js\n ** module id = 0\n ** module chunks = 0\n **/","const Orb = require('./orb.js');\n\nclass Board {\n\n  constructor(width, height, row, col, offsetX=0, offsetY=0, canvas) {\n    this.timeToMove = 8000;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    this.row = row;\n    this.col = col;\n    this.width = width;\n    this.height = height;\n    this.grid = new Array(row);\n    this.canvas = canvas;\n    this.matchedOrbs = [];\n    this.resolving = false;\n    this.timeLeft = 0;\n    this.colorMatches = {water: 0, wind: 0, electric: 0, wood: 0, fire: 0, psion: 0};\n    this.matchCount = 0;\n    this.turnCount = 0;\n    this.currentAnimation = 0;\n    this.swapping = false;\n    this.timerDisplay = document.getElementById(\"timer\");\n    this.fireDisplay = document.getElementById(\"fire-matches\");\n    this.waterDisplay = document.getElementById(\"water-matches\");\n    this.woodDisplay = document.getElementById(\"wood-matches\");\n    this.electricDisplay = document.getElementById(\"electric-matches\");\n    this.psionDisplay = document.getElementById(\"psion-matches\");\n    this.windDisplay = document.getElementById(\"wind-matches\");\n    this.totalDisplay = document.getElementById(\"total-matches\");\n    for (var i = 0; i < row; i++) {\n      this.grid[i] = new Array(col);\n    }\n\n  }\n\n  checkMouseDown(e) { //on mouse down\n    e.stopPropagation();\n    this.mouseX = e.pageX - this.canvas.offsetLeft -10;\n    this.mouseY = e.pageY - this.canvas.offsetTop - 10;\n    this.canvas.className = 'grabbing';\n    this.eachOrb( (orb) => {\n      if(Math.sqrt((this.mouseX-orb.x)*(this.mouseX-orb.x) + (this.mouseY-orb.y)*(this.mouseY-orb.y)) < orb.radius) {\n        this.selectedOrb = orb;\n        orb.select();\n        this.canvas.onmousemove = this.checkMouseMove.bind(this);\n        this.canvas.onmouseup = this.checkMouseUp.bind(this);\n      }\n    })\n  }\n\n  checkMouseUp() { //on mouse up\n    this.canvas.className = '';\n    this.canvas.onmousemove = null;\n    this.canvas.onmouseup = null;\n    this.selectedOrb.unselect();\n    this.selectedOrb = null;\n    this.swapping = false;\n    if(this.nextOrb) {\n      this.nextOrb.unselect();\n    }\n    clearTimeout(this.timer);\n    if(this.timer){\n      this.resolveBoard();\n    }\n    this.timer = null;\n  }\n\n  checkMouseMove(e) { //on mouse move\n    e.stopPropagation();\n    this.mouseX = e.pageX - this.canvas.offsetLeft -10;\n    this.mouseY = e.pageY - this.canvas.offsetTop - 10;\n    this.eachOrb( (orb) => {\n      if(Math.sqrt((this.mouseX-orb.x)*(this.mouseX-orb.x) + (this.mouseY-orb.y)*(this.mouseY-orb.y)) < orb.radius) {\n        if (this.selectedOrb != orb && !this.timer) {\n          this.timer = setTimeout(this.checkMouseUp.bind(this), this.timeToMove);\n          this.timeLeft = this.timeToMove/1000;\n          this.timerStart = Date.now();\n          this.swapOrbs(orb);\n        } else if (this.selectedOrb != orb && !this.swapping) {\n          this.swapOrbs(orb);\n        } else if (this.selectedOrb != orb && this.swapping && this.nextOrb != orb) {\n          this.completeSwap();\n          this.swapOrbs(orb);\n        }\n      }\n    })\n    if(this.mouseX < 3 || this.mouseY < 3 || this.mouseX > this.width -3 || this.mouseY > this.height -3 ) {\n      this.checkMouseUp();\n    }\n  }\n\n  checkRow(grid) { //row check when resolving board\n    grid.forEach((row) => {\n      let matches = [];\n      let lastColor = null;\n      row.forEach((orb) => {\n        if(lastColor) {\n          if(lastColor === orb.color) {\n            matches.push(orb);\n          } else if(lastColor != orb.color && matches.length > 2) {\n            if(this.matchedAlready(matches)){}\n            else {\n              this.matchCount++;\n              this.matchedOrbs.push(matches);\n            }\n            matches = [];\n            matches.push(orb);\n            lastColor = orb.color;\n          } else {\n            matches = [];\n            matches.push(orb);\n            lastColor = orb.color;\n          }\n        } else {\n          lastColor = orb.color;\n          matches.push(orb);\n        }\n      })\n      if(matches.length > 2) {\n        if(this.matchedAlready(matches)){}\n        else {\n          this.matchCount++;\n          this.matchedOrbs.push(matches);\n        }\n      }\n    })\n  }\n\n  checkCol(grid) {  //column check for resvoling board\n    let transposedGrid = this.transpose(grid);\n    this.checkRow(transposedGrid);\n  }\n\n  populate(){ //generates random orbs\n    this.grid.forEach((row, i) => {\n      for ( var j=0; j < row.length; j++) {\n        const x = +(j*this.width/this.col + this.offsetX).toFixed(7);\n        const y = +(i*this.height/this.row + this.offsetY).toFixed(7);\n        this.grid[i][j] = new Orb(x,y);\n      }\n    });\n    this.resolveBoard();\n  }\n\n  draw(ctx) { //handles graphics and animations\n    if(this.timeLeft != 0) {\n      this.timeLeft = ((this.timeToMove - (Date.now() - this.timerStart))/1000).toFixed(2);\n    }\n    this.timerDisplay.innerHTML = this.timeLeft;\n    if(this.resolving && !this.falling()) {\n      this.skyfall();\n    }\n    ctx.clearRect(0,0,this.width+this.offsetX,this.height+this.offsetY);\n    this.eachOrb((orb) => orb.draw(ctx));\n    if(this.swapping && this.swapping < 5) {\n      let image = document.getElementById(this.swapColor)\n      ctx.drawImage(image, this.currentX - 34, this.currentY - 34 ,68 ,68);\n      this.currentX = this.currentX - this.xDiff;\n      this.currentY = this.currentY - this.yDiff;\n      this.swapping ++;\n    } else if(this.swapping == 5 && this.selectedOrb) {\n      this.completeSwap();\n    };\n    if(this.selectedOrb) {\n      let image = document.getElementById(this.selectedOrb.color);\n      ctx.drawImage(image, this.mouseX - 34, this.mouseY - 34, 68, 68);\n    }\n  }\n\n  falling() { //returns true if any orbs are currently falling\n    let result = false;\n    this.eachOrb( (orb) => {\n      if (orb.targetY) {\n        result = true;\n      }\n    })\n    return result;\n  }\n\n  skyfall() { //generates new orbs from the top after matches are made\n    if(!this.disappearing()){\n      this.skyfalling = false;\n      this.grid[0].forEach( orb => {\n        if(orb.disappeared) {\n          orb.generateNewColor();\n          orb.respawn();\n        }\n      })\n      for(let i=this.grid.length-1; i >= 1; i--) {\n        for(let j=this.grid.length-1; j >= 0; j--) {\n          if(this.grid[i][j].disappeared && !this.grid[i-1][j].disappeared) {\n            this.skyfalling = true;\n            let tempOrb = this.grid[i][j];\n            this.dropOrb(this.grid[i-1][j], this.grid[i][j]);\n            this.grid[i][j] = this.grid[i-1][j];\n            this.grid[i-1][j] = tempOrb;\n          }\n        }\n      }\n      if(!this.skyfalling) {\n        clearInterval(this.animation);\n        this.currentAnimation = 0;\n        this.matchedOrbs = [];\n        this.resolveBoard();\n      }\n    }\n  }\n\n  disappearing() { //returns true if orbs are currently being matched\n    let result = false;\n    this.eachOrb( orb => {\n      if(orb.disappearing) {\n        result = true;\n      }\n    })\n    return result;\n  }\n\n  swapOrbs(otherOrb) { //function to swap two orbs\n    this.swapping = 1;\n    this.xDiff = (otherOrb.x - this.selectedOrb.x)/10;\n    this.yDiff = (otherOrb.y - this.selectedOrb.y)/10;\n    this.currentX = otherOrb.x - this.xDiff;\n    this.currentY = otherOrb.y - this.yDiff;\n    this.swapColor = otherOrb.color;\n    otherOrb.select();\n    this.nextOrb = otherOrb;\n  }\n\n  completeSwap() { //function that is called when animations are finished, or when another orb is being moved\n    let tempColor = this.selectedOrb.color;\n    this.selectedOrb.color = this.nextOrb.color;\n    this.selectedOrb.unselect();\n    this.nextOrb.color = tempColor;\n    this.selectedOrb = this.nextOrb;\n    this.swapping = false;\n  }\n\n  matchedAlready(matches) { //checks if there are duplicate matches\n    let found = false;\n    for (let i = 0; i < this.matchedOrbs.length; i++) {\n      for (let j = 0; j < matches.length; j++) {\n        if (this.matchedOrbs[i].includes(matches[j])) {\n          matches.splice(j,1);\n          this.matchedOrbs[i] = this.matchedOrbs[i].concat(matches)\n          found = true;\n          break;\n        }\n      }\n      if(found) {break;}\n    }\n    return found;\n  }\n\n  dropOrb(orb, disappearedOrb) { //function that transfers matched orbs Y position to the new one\n    let oldY = orb.y;\n    orb.targetY = disappearedOrb.y;\n    disappearedOrb.y = oldY;\n  }\n\n  resolveBoard() { //function to resolve the board at end of every round\n    this.timeLeft = 0;\n    this.resolving = true;\n    this.canvas.onmousedown = null;\n    this.checkRow(this.grid);\n    this.checkCol(this.grid);\n    if(this.matchedOrbs.length === 0) {\n      this.displayScore();\n      this.turnCount ++;\n      this.colorMatches = {water: 0, wind: 0, electric: 0, wood: 0, fire: 0, psion: 0};\n      this.matchCount = 0;\n      this.resolving = false;\n      this.canvas.onmousedown = this.checkMouseDown.bind(this);\n    }\n    if(this.matchedOrbs.length > 0) {\n      this.matchedOrbs.forEach( (set) => {\n        this.colorMatches[set[0].color] ++;\n      });\n      this.matchedOrbs[0].forEach(orb => orb.disappear());\n      this.animation = setInterval(() => {\n        this.currentAnimation ++;\n        if (this.currentAnimation < this.matchedOrbs.length) {\n          this.matchedOrbs[this.currentAnimation].forEach(orb => orb.disappear());\n        }\n      }, 500)\n    }\n  }\n\n  displayScore() {\n    if(this.turnCount === 0) {\n      this.colorMatches = {water: 0, wind: 0, electric: 0, wood: 0, fire: 0, psion: 0};\n      this.matchCount = 0;\n    }\n    this.fireDisplay.innerHTML = this.colorMatches['fire'];\n    this.waterDisplay.innerHTML = this.colorMatches['water'];\n    this.woodDisplay.innerHTML = this.colorMatches['wood'];\n    this.electricDisplay.innerHTML = this.colorMatches['electric'];\n    this.psionDisplay.innerHTML = this.colorMatches['psion'];\n    this.windDisplay.innerHTML = this.colorMatches['wind'];\n    this.totalDisplay.innerHTML = this.matchCount;\n  }\n\n  transpose(array) { //helper function for transposing the array\n    return Object.keys(array[0]).map(\n      function (c) { return array.map(function (r) { return r[c]; }); }\n      );\n    }\n\n  eachOrb(callback) { //helper function to iterate over each orb\n    this.grid.forEach((row) => {\n      row.forEach((orb) => {\n        callback(orb);\n      });\n    });\n  }\n\n}\n\nmodule.exports = Board;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/board.js\n ** module id = 1\n ** module chunks = 0\n **/","const COLORS = ['water', 'wood', 'fire', 'electric', 'wind', 'psion'];\n\nclass Orb {\n\n  constructor(x,y) {\n    this.radius = 34;\n    this.x = x;\n    this.y = y;\n    this.opacity = 1;\n    this.targetY = null;\n    this.color = COLORS[Math.floor(Math.random()*COLORS.length)];\n  }\n\n  generateNewColor() { //randomly generates a color from the color array\n    this.color = COLORS[Math.floor(Math.random()*COLORS.length)];\n  }\n\n  draw(ctx) { //animations for the orb\n    ctx.save();\n    this.img = COLORS[this.color]\n    if(this.disappearing && this.opacity >= 0.03) {\n      this.opacity = this.opacity - 0.03;\n    } else if (this.opacity < 0.03){\n      this.disappearing = false;\n      this.disappeared = true;\n    } else {\n      this.disappearing = false;\n    }\n    if(this.targetY && this.y <= (this.targetY + 0.1 - 20/3)) {\n      this.y = +(this.y + 20/3).toFixed(7);\n    } else {\n      this.targetY = null;\n    }\n    ctx.globalAlpha = this.opacity;\n    let image = document.getElementById(this.color);\n    ctx.drawImage(image,this.x - 34,this.y - 34,this.radius*2,this.radius*2);\n    ctx.restore();\n  }\n\n  disappear() {\n    this.disappearing = true;\n  }\n\n  respawn() {\n    this.disappeared = false;\n    this.opacity = 1;\n  }\n\n  select() {\n    this.opacity = 0.4;\n  }\n\n  unselect() {\n    this.opacity = 1;\n  }\n\n}\n\nmodule.exports = Orb;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/orb.js\n ** module id = 2\n ** module chunks = 0\n **/","\nclass GameView {\n  \n  constructor(board, ctx) {\n    this.ctx = ctx;\n    this.board = board;\n    this.board.populate();\n  }\n\n  start() {\n    this.lastTime = 0;\n    requestAnimationFrame(this.animate.bind(this));\n  }\n\n  animate(time) {\n    this.board.draw(this.ctx);\n    this.lastTime = time;\n    requestAnimationFrame(this.animate.bind(this));\n  }\n\n}\n\nmodule.exports = GameView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/game_view.js\n ** module id = 3\n ** module chunks = 0\n **/"],"sourceRoot":""}